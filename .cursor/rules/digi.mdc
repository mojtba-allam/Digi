---
description: 
globs: 
alwaysApply: true
---
1. Introduction & Purpose
This document outlines the coding standards, conventions, and architectural principles to be
followed for the backend development. Adherence to these guidelines is crucial for
maintaining code quality, consistency, readability, scalability, and maintainability across the
project. All developers working on the Laravel backend are expected to familiarize
themselves with and follow these conventions.
2. General Coding Standards
● Laravel Best Practices:
○ Prioritize the use of Laravel's built-in features, helpers, and conventions (e.g.,
Eloquent ORM, Blade templating (if applicable for any server-side views),
Form Requests, API Resources, Service Container, Facades where
appropriate).
○ Follow the official Laravel documentation for guidance on framework-specific
features.
● PHP Standards (PSR-12):
○ All PHP code MUST adhere to the PSR-12 Extended Coding Style Guide.
○ This includes guidelines on file formatting, line lengths, indentation (4 spaces,
no tabs), control structures, method and class declarations, etc.
○ Utilize tools like PHP CS Fixer or PHP_CodeSniffer configured for PSR-12 to
automate compliance.
● Naming Conventions:
○ Descriptive Names: Variable, method, class, and other identifier names must
be clear, descriptive, and unambiguous. Avoid overly short or cryptic names.
○ Variables & Functions/Methods: camelCase (e.g., $userName,
calculateTotalAmount()).
○ Classes & Interfaces: PascalCase (e.g., UserService,
OrderRepositoryInterface).
○ Constants: UPPER_SNAKE_CASE (e.g., const MAX_LOGIN_ATTEMPTS =
5;).
○ Database Table Names: snake_case, plural (e.g., users, product_orders).
○ Database Column Names: snake_case, singular (e.g., first_name, order_id).
○ Boolean Variables/Methods: Prefix with is, has, should (e.g., $isActive,
hasPermission()).
● Comments:
○ Write clear and concise comments to explain complex logic, non-obvious
decisions, or important business rules.
○ Use PHPDoc blocks for classes, methods, and properties to describe their
purpose, parameters, and return types.
○ Avoid over-commenting obvious code. Well-named identifiers should make
the code largely self-documenting.
3. Object-Oriented Programming (OOP) Principles
● SOLID Principles: Actively apply SOLID principles to design robust, maintainable,
and flexible code:
○ Single Responsibility Principle (SRP): Classes and methods should have one,
and only one, reason to change.
○ Open/Closed Principle (OCP): Software entities (classes, modules, functions,
etc.) should be open for extension but closed for modification.
○ Liskov Substitution Principle (LSP): Subtypes must be substitutable for their
base types.
○ Interface Segregation Principle (ISP): Clients should not be forced to depend
on interfaces they do not use.
○ Dependency Inversion Principle (DIP): Depend upon abstractions, not
concretions.
● Design Patterns:
○ Implement appropriate design patterns (e.g., Factory, Strategy, Observer,
Decorator) when they solve a specific problem elegantly and improve the
codebase structure.
○ Avoid over-engineering; use patterns judiciously where they add clear value.
4. Architecture & Structure
● Domain-Driven Design (DDD) Principles:
○ Apply DDD concepts to model the business domain accurately.
○ Focus on defining clear module boundaries, aggregates, entities, value
objects, and domain services.
○ Establish a ubiquitous language shared between developers and domain
experts.
● Modular Architecture (nwidart/laravel-modules):
○ The project will utilize the nwidart/laravel-modules package to create and
manage distinct modules.
○ Each module should encapsulate a specific business domain or feature set,
promoting loose coupling and high cohesion.
○ Follow the package's conventions for module structure and organization.
● Model-Controller-Service-Repository-View (MCSRV) Pattern:
○ Models (Eloquent): Represent database tables and contain data-related
logic, relationships, accessors, and mutators. Keep models lean, focusing on
data representation.
○ Controllers:
■ Solely responsible for handling incoming HTTP requests and returning
appropriate HTTP responses.
■ Should be thin and delegate business logic to Service classes.
■ Handle request validation (using Form Requests), authentication,
authorization, and transforming data for the response (using API
Resources).
○ Services:
■ Contain the core business logic, orchestrating operations and
coordinating between different components (e.g., repositories, external
services).
■ Services are injected into controllers.
■ Services use Repositories to interact with the data persistence layer.
○ Repositories:
■ Implement the Repository pattern to abstract the data access layer.
■ Provide an interface for data retrieval and persistence operations
(e.g., findById, create, update, delete, custom queries).
■ Repositories interact directly with Eloquent models or the query
builder.
■ This allows for easier testing and potential swapping of data sources
in the future.
■ Define repository interfaces and bind their implementations in the
Service Provider.
○ Views (Blade/API Resources):
■ For traditional web applications, Blade templates are used for
presentation.
■ For APIs, Laravel API Resources are used to transform models and
collections into JSON responses.
5. API Development
● API Versioning:
○ All public APIs MUST be versioned (e.g., /api/v1/users, /api/v2/products).
○ Versioning can be done via URI path, headers, or query parameters. URI path
versioning is preferred for clarity unless specific reasons dictate otherwise.
● Request Validation:
○ Utilize Laravel's Form Requests for validating incoming API request data.
○ Define validation rules and custom error messages within Form Request
classes.
○ Keep controllers clean by moving validation logic out.
● API Resource Transformations:
○ Use Laravel API Resources (e.g., JsonResource, ResourceCollection) to
format and standardize JSON responses.
○ This ensures consistent API output and allows for conditional attributes and
relationship loading.
● Status Codes & Error Handling:
○ Use appropriate HTTP status codes to indicate the outcome of API requests
(e.g., 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 403
Forbidden, 404 Not Found, 500 Internal Server Error).
○ Provide clear and informative error messages in JSON format for client-side
and server-side errors. Laravel's default exception handling can be
customized for this.
6. Performance Optimization
● Efficient Code: Write code that is performant and mindful of resource consumption
(CPU, memory).
● Database Indexing:
○ Implement proper database indexes on columns frequently used in WHERE
clauses, JOIN conditions, and ORDER BY clauses to improve query
performance.
○ Regularly review query performance and add/adjust indexes as needed.
● Query Optimization:
○ Write efficient database queries. Avoid N+1 problems by using eager loading
(with()) for Eloquent relationships.
○ Select only necessary columns (select()).
○ Use database transactions for operations that require atomicity.
○ Analyze slow queries using tools like Laravel Telescope, Debugbar, or
database-specific query analysis tools.
● Caching: Utilize caching (e.g., Redis) for frequently accessed data that doesn't
change often to reduce database load and improve response times.
7. Testing
● Test Types:
○ Unit Tests: Test individual classes, methods, or functions in isolation. Focus
on business logic within services, repositories, and other helper classes.
○ Feature Tests (Integration/HTTP Tests): Test the full request-response
cycle of API endpoints or application features, interacting with multiple
components (controllers, services, database).
● Mocking:
○ Use Mockery (or Laravel's built-in mocking capabilities) to mock external
services, dependencies, and complex objects to isolate the code under test.
● Model Factories:
○ Define model factories for all Eloquent models.
○ Use factories to generate realistic fake data for seeding databases in test
environments and for setting up test scenarios.
● Test Structure (AAA Pattern):
○ Structure tests clearly using the Arrange, Act, Assert (AAA) pattern for
readability and maintainability.
■ Arrange: Set up the test conditions, create objects, mock
dependencies.
■ Act: Execute the code being tested.
■ Assert: Verify the outcome and assertions.
● Test Coverage:
○ Edge Cases: Write test cases that cover boundary conditions, invalid inputs,
and unexpected scenarios.
○ Happy Paths & Failure Cases: Test both valid data scenarios (happy paths)
and invalid data/error scenarios (failure cases) to ensure robustness.
● API Response Testing:
○ Use Laravel's built-in JSON testing helpers like assertJsonStructure(),
assertJsonFragment(), assertStatus() to validate API response formats, data,
and status codes.
● Authentication & Authorization Testing:
○ Write tests to ensure correct access controls, verifying that endpoints are
properly protected and that users with different roles/permissions have
appropriate access.
● Test Independence:
○ Each test case should be independent and capable of running on its own
without relying on the state or outcome of previous tests. Use
RefreshDatabase trait or similar mechanisms to ensure a clean state for each
test.
● Test Naming: Name test methods descriptively, often reflecting the method being
tested and the scenario (e.g., test_user_can_register_successfully(),
test_update_fails_if_name_is_missing()).
8. Enforcement & Updates
● Code Reviews: All code contributions must undergo a peer review process before
being merged into the main development branch. Reviewers should check for
adherence to these conventions.
● Automated Tools: Linters (PHP CS Fixer, ESLint for frontend if applicable) and
static analysis tools should be integrated into the CI/CD pipeline to automatically
check for style violations.
● Living Document: This document is a living guide and may be updated as the
project evolves or new best practices emerge. Changes will be communicated to the
team.